const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const RPC = process.env.RPC_URL;
const PROXY = process.env.PROXY_ADDRESS;
const PRIVATE_KEY = process.env.PRIVATE_KEY;
const ICONS_DIR = process.env.ICONS_DIR || path.join(__dirname, '..', 'icons-64');
const BATCH_SIZE = parseInt(process.env.BATCH_SIZE) || 10;
const OUTPUT_FILE = process.env.OUTPUT_FILE || path.join(__dirname, '..', 'docs', 'deployment-report.md');

if (!RPC || !PROXY || !PRIVATE_KEY) {
    console.error('Required env vars: RPC_URL, PROXY_ADDRESS, PRIVATE_KEY');
    process.exit(1);
}

function findAllPngs(dir) {
    const results = [];
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            results.push(...findAllPngs(fullPath));
        } else if (entry.name.endsWith('.png')) {
            results.push(fullPath);
        }
    }
    return results;
}

function pathToSlug(filePath) {
    const relative = path.relative(ICONS_DIR, filePath);
    return relative.replace(/\.png$/, '').replace(/\\/g, '/');
}

function formatNumber(n) {
    return n.toLocaleString('en-US');
}

function generateReport(data) {
    const {
        network,
        chainId,
        proxyAddress,
        implementationAddress,
        deploymentTxHash,
        startTime,
        endTime,
        batches,
        totalIcons,
        successCount,
        failCount,
        totalBytes,
        totalGasUsed,
        gasPrice
    } = data;

    const duration = ((endTime - startTime) / 1000 / 60).toFixed(1);
    const avgGasPerIcon = successCount > 0 ? totalGasUsed / BigInt(successCount) : BigInt(0);
    const avgBytesPerIcon = successCount > 0 ? Math.round(totalBytes / successCount) : 0;
    
    const ethCost = Number(totalGasUsed) * gasPrice / 1e9;
    const ethPrices = [2000, 2500, 3000, 3500, 4000];

    let md = `# IconRegistry Deployment Report

Generated: ${new Date().toISOString()}

## Summary

| Metric | Value |
|--------|-------|
| Network | ${network} |
| Chain ID | ${chainId} |
| Proxy Contract | \`${proxyAddress}\` |
| Implementation | \`${implementationAddress}\` |
| Total Icons | ${formatNumber(totalIcons)} |
| Successfully Deployed | ${formatNumber(successCount)} |
| Failed | ${formatNumber(failCount)} |
| Total Data Size | ${(totalBytes / 1024 / 1024).toFixed(2)} MB |
| Deployment Duration | ${duration} minutes |

## Gas Costs

| Metric | Value |
|--------|-------|
| Total Gas Used | ${formatNumber(Number(totalGasUsed))} |
| Average Gas per Icon | ${formatNumber(Number(avgGasPerIcon))} |
| Average Bytes per Icon | ${formatNumber(avgBytesPerIcon)} |
| Gas Price Used | ${gasPrice} gwei |
| Total ETH Cost | ${ethCost.toFixed(4)} ETH |

### Cost Estimates at Different ETH Prices

| ETH Price | Deployment Cost (USD) |
|-----------|----------------------|
${ethPrices.map(p => `| $${formatNumber(p)} | $${formatNumber(Math.round(ethCost * p))} |`).join('\n')}

## Storage Economics

Each icon is stored via SSTORE2, which costs approximately:
- ~20,000 gas base cost per SSTORE2 write
- ~200 gas per byte of data stored

For ${formatNumber(successCount)} icons averaging ${formatNumber(avgBytesPerIcon)} bytes:
- Estimated storage: ${(totalBytes / 1024 / 1024).toFixed(2)} MB on-chain
- Cost per KB: ~${((ethCost * 1000) / (totalBytes / 1024)).toFixed(6)} ETH

## Batch Transactions

| Batch | Icons | Bytes | Gas Used | Tx Hash |
|-------|-------|-------|----------|---------|
`;

    batches.forEach((batch, i) => {
        const status = batch.success ? '' : ' (FAILED)';
        const txLink = batch.txHash ? `\`${batch.txHash.slice(0, 10)}...${batch.txHash.slice(-8)}\`` : 'N/A';
        md += `| ${i + 1}${status} | ${batch.iconCount} | ${formatNumber(batch.bytes)} | ${formatNumber(Number(batch.gasUsed))} | ${txLink} |\n`;
    });

    md += `
## Icon Categories

`;
    const categories = {};
    batches.forEach(b => {
        b.slugs.forEach(slug => {
            const cat = slug.split('/')[0] || 'root';
            categories[cat] = (categories[cat] || 0) + 1;
        });
    });
    
    Object.entries(categories)
        .sort((a, b) => b[1] - a[1])
        .forEach(([cat, count]) => {
            md += `- **${cat}**: ${formatNumber(count)} icons\n`;
        });

    md += `
## How to Verify

\`\`\`bash
# Check total icons
cast call ${proxyAddress} "totalIcons()(uint256)" --rpc-url <RPC_URL>

# Get icon by slug
cast call ${proxyAddress} "getIconBySlug(string)(bytes)" "chains/ethereum" --rpc-url <RPC_URL>
\`\`\`

## Contract Addresses

- **Proxy (use this)**: \`${proxyAddress}\`
- **Implementation**: \`${implementationAddress}\`

---

*Report generated by iconregistry.eth deployment script*
`;

    return md;
}

async function main() {
    console.log('=== IconRegistry Batch Deployment ===\n');
    
    const pngs = findAllPngs(ICONS_DIR);
    console.log(`Found ${pngs.length} PNG files`);
    console.log(`Batch size: ${BATCH_SIZE}`);
    console.log(`Output: ${OUTPUT_FILE}\n`);

    const reportData = {
        network: 'Tenderly Virtual Mainnet',
        chainId: 73571,
        proxyAddress: PROXY,
        implementationAddress: 'TBD',
        deploymentTxHash: null,
        startTime: Date.now(),
        endTime: null,
        batches: [],
        totalIcons: pngs.length,
        successCount: 0,
        failCount: 0,
        totalBytes: 0,
        totalGasUsed: BigInt(0),
        gasPrice: 30
    };

    for (let i = 0; i < pngs.length; i += BATCH_SIZE) {
        const batch = pngs.slice(i, i + BATCH_SIZE);
        const slugs = [];
        const hexDatas = [];
        const widths = [];
        const heights = [];
        let batchBytes = 0;

        for (const png of batch) {
            const slug = pathToSlug(png);
            const data = fs.readFileSync(png);
            slugs.push(slug);
            hexDatas.push('0x' + data.toString('hex'));
            widths.push(64);
            heights.push(64);
            batchBytes += data.length;
        }

        const batchRecord = {
            index: Math.floor(i / BATCH_SIZE) + 1,
            slugs,
            iconCount: batch.length,
            bytes: batchBytes,
            gasUsed: BigInt(0),
            txHash: null,
            success: false
        };

        const slugsArg = `[${slugs.map(s => `"${s}"`).join(',')}]`;
        const datasArg = `[${hexDatas.join(',')}]`;
        const widthsArg = `[${widths.join(',')}]`;
        const heightsArg = `[${heights.join(',')}]`;

        try {
            const cmd = `cast send ${PROXY} "setIconsBatch(string[],bytes[],uint32[],uint32[])" '${slugsArg}' '${datasArg}' '${widthsArg}' '${heightsArg}' --private-key ${PRIVATE_KEY} --rpc-url ${RPC} --json`;
            
            const result = execSync(cmd, { maxBuffer: 100 * 1024 * 1024 }).toString();
            const json = JSON.parse(result);
            
            batchRecord.gasUsed = BigInt(json.gasUsed);
            batchRecord.txHash = json.transactionHash;
            batchRecord.success = true;

            reportData.totalGasUsed += batchRecord.gasUsed;
            reportData.totalBytes += batchBytes;
            reportData.successCount += batch.length;

            const progress = ((i + batch.length) / pngs.length * 100).toFixed(1);
            console.log(`[${progress}%] Batch ${batchRecord.index}: ${batch.length} icons, ${formatNumber(Number(batchRecord.gasUsed))} gas`);
        } catch (err) {
            reportData.failCount += batch.length;
            console.error(`Batch ${batchRecord.index} FAILED:`, err.message.slice(0, 100));
        }

        reportData.batches.push(batchRecord);
    }

    reportData.endTime = Date.now();

    // Generate and save report
    const report = generateReport(reportData);
    fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
    fs.writeFileSync(OUTPUT_FILE, report);

    console.log('\n=== COMPLETE ===');
    console.log(`Icons: ${reportData.successCount}/${reportData.totalIcons}`);
    console.log(`Gas: ${formatNumber(Number(reportData.totalGasUsed))}`);
    console.log(`Report: ${OUTPUT_FILE}`);
}

main().catch(console.error);
